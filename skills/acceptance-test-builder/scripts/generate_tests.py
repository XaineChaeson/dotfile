#!/usr/bin/env python
"""
Generate a user-perspective acceptance test skeleton from a feature list.

Input formats:
- JSON list of objects with keys: action, expected, notes (optional)
- Text or Markdown file with lines: action | expected | notes
"""
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import List, Dict


def _load_features(path: Path) -> List[Dict[str, str]]:
    if path.suffix.lower() == ".json":
        data = json.loads(path.read_text(encoding="utf-8"))
        features = []
        for item in data:
            if isinstance(item, str):
                features.append({"action": item, "expected": ""})
            else:
                features.append(
                    {
                        "action": str(item.get("action", "")),
                        "expected": str(item.get("expected", "")),
                        "notes": str(item.get("notes", "")),
                    }
                )
        return features

    features = []
    for raw in path.read_text(encoding="utf-8").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        parts = [part.strip() for part in line.split("|")]
        action = parts[0] if len(parts) > 0 else ""
        expected = parts[1] if len(parts) > 1 else ""
        notes = parts[2] if len(parts) > 2 else ""
        features.append({"action": action, "expected": expected, "notes": notes})
    return features


def _render_script(title: str, features: List[Dict[str, str]]) -> str:
    lines = [
        "#!/usr/bin/env python",
        '"""',
        f"Acceptance test skeleton: {title}",
        "Generated by generate_tests.py",
        '"""',
        "from __future__ import annotations",
        "",
        "import argparse",
        "import json",
        "import os",
        "import sys",
        "from pathlib import Path",
        "from typing import Dict",
        "",
        "",
        "def _load_config(path: str) -> Dict[str, str]:",
        "    cfg_path = Path(path)",
        "    if not cfg_path.exists():",
        "        return {}",
        "    return json.loads(cfg_path.read_text(encoding=\"utf-8\"))",
        "",
        "",
        "def _build_config(path: str) -> Dict[str, str]:",
        "    cfg = _load_config(path)",
        "    return {",
        "        \"config_path\": str(Path(path)),",
        "        \"env_name\": os.getenv(\"ENV_NAME\", cfg.get(\"ENV_NAME\", \"\")),",
        "        \"base_url\": os.getenv(\"BASE_URL\", cfg.get(\"BASE_URL\", \"\")),",
        "        \"rpc_url\": os.getenv(\"RPC_URL\", cfg.get(\"RPC_URL\", \"\")),",
        "    }",
        "",
        "",
        "CONFIG: Dict[str, str] = {}",
        "",
        "",
        "FEATURES = [",
    ]
    for feature in features:
        action = feature.get("action", "").replace("\"", "\\\"")
        expected = feature.get("expected", "").replace("\"", "\\\"")
        notes = feature.get("notes", "").replace("\"", "\\\"")
        lines.append(
            f"    {{\"action\": \"{action}\", \"expected\": \"{expected}\", \"notes\": \"{notes}\"}},"
        )
    lines.extend(
        [
            "]",
            "",
            "",
            "def _log_step(step_no: int, action: str, expected: str, observed: str, result: str) -> None:",
            "    print(f\"STEP {step_no}: {action}\")",
            "    print(f\"EXPECTED: {expected}\")",
            "    print(f\"OBSERVED: {observed}\")",
            "    print(f\"RESULT: {result}\")",
            "",
            "",
            "def _env_snapshot() -> None:",
            "    print(\"ENV SNAPSHOT\")",
            "    if CONFIG.get(\"config_path\"):",
            "        print(f\"CONFIG_PATH={CONFIG['config_path']}\")",
            "    if CONFIG.get(\"env_name\"):",
            "        print(f\"ENV_NAME={CONFIG['env_name']}\")",
            "    if CONFIG.get(\"base_url\"):",
            "        print(f\"BASE_URL={CONFIG['base_url']}\")",
            "    if CONFIG.get(\"rpc_url\"):",
            "        print(f\"RPC_URL={CONFIG['rpc_url']}\")",
            "",
            "",
            "def _execute_step(step: Dict[str, str]) -> str:",
            "    # TODO: Implement user-perspective verification for this step.",
            "    # Return an observed signal or outcome string.",
            "    raise NotImplementedError(\"Implement step logic\")",
            "",
            "",
            "def _cleanup() -> None:",
            "    # TODO: Remove local temp files or close sessions if applicable.",
            "    pass",
            "",
            "",
            "def run() -> int:",
            "    parser = argparse.ArgumentParser()",
            "    parser.add_argument(\"--config\", default=\"config.json\", help=\"Config JSON path\")",
            "    args = parser.parse_args()",
            "    global CONFIG",
            "    CONFIG = _build_config(args.config)",
            "    dry_run = os.getenv(\"DRY_RUN\", \"0\") == \"1\"",
            "    _env_snapshot()",
            "    for idx, step in enumerate(FEATURES, start=1):",
            "        action = step.get(\"action\", \"\")",
            "        expected = step.get(\"expected\", \"\")",
            "        if dry_run:",
            "            observed = \"dry run\"",
            "            result = \"PASS\"",
            "        else:",
            "            observed = _execute_step(step)",
            "            result = \"PASS\" if observed else \"FAIL\"",
            "        _log_step(idx, action, expected, observed, result)",
            "        if result != \"PASS\":",
            "            _cleanup()",
            "            return 1",
            "    _cleanup()",
            "    return 0",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    sys.exit(run())",
        ]
    )
    return "\n".join(lines) + "\n"


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--features", required=True, help="Path to features file")
    parser.add_argument(
        "--out",
        default="tests/manual/acceptance.py",
        help="Output script path (default: tests/manual/acceptance.py)",
    )
    parser.add_argument("--title", default="Acceptance Test", help="Title for the script")
    args = parser.parse_args()

    features_path = Path(args.features)
    out_path = Path(args.out)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    features = _load_features(features_path)
    content = _render_script(args.title, features)
    out_path.write_text(content, encoding="utf-8")
    out_path.chmod(0o755)
    print(f"Wrote skeleton to {out_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
